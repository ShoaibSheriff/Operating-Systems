
## Aim
This project modifies the linux kernel and adds a system call "sys_cpenc" that supports file encryption. A user program "xcpenc.c" tests the various functionalities of the system call.

## File descriptions

1) xcpenc.c - This is a user-application which invokes the sys_cpenc() system call and tests its functionalities.
2) sys_cpenc.c - This is the loadable kernel module which consists of the system call implementation. The function supports plain copy, encryption and decryption. 
	             In case of encryption, a password needs to be provided by the user. For decryption, the same password is required to get the original text back.
3) e_struct.h - A struct that is passed as a void * from user code to kernel code. Both the above 2 files need to import this header file.
4) Makefile - This file compiles the above 2 source files and generates the executables(.ko files). The advantage of a loadable module is that any changes are immediately reflected in the functionality.
5) kernel.config - A kernel config file to create minimalistic kernel file. After continued efforts, the length is currently LESS THAN 2200 lines.
6) install_module.sh - This script helps to unload older module and load the module again with code changes.
7) Test files (test01.sh,....test11.sh) - Batch files to test and verify various functionalities of the system call.

Note :	Since xcpenc.c uses openssl/md5.h, the Makefile needs ssl library.
		Some of the AES cipher encryption code has been borrowed from www.kernel.org.


## User Level Code

The user needs to call the executables genarted by make command with all the necessary paramteres :
	"./xcpenc -p 12345678 -e  "file_in.txt" "file_out.txt"

Here , the password is 12345678, input is file_in.txt and output is file_out.txt. Thhe user program uses getopt() command to read the parameters.
It then verifies with rules like:
1. Encryption/decryption need password.
2. A command only supports a single operation.
3. Input file must exist at path provided and must be readable.
4. Password hsould be atleast 6 chars long.

Since passing the password in plain text to kernel may be risky, the user level code instead uses MD5 to hash the password and stores this inside.
After this, the data is passed to the system cal.
		
The system calls takes in the following struct as a void pointer :
```c
typedef struct E_Struct {
	
	char* infile; // Input file name (absolute/relative)
	char* outfile; // Output file name (absolute/relative)
	void *keybuf; // hash of the password (from user)
   
	int keylen; // length of the hash
	int flags; //operation requested (e/d/c);

} E_Struct;
```


## Kernel level code

First, we check if the data recieved is null. Then the code checks if it can read the user memory address. If no, -EACCES is returned as error.
If access is available, we copy the struct in to a kernel memory allocated struct. Before everything else, we check the operation requested
to verify that it is indeed one of the supported ones. If its an encrypt/decrypt operation, we next try to copy the keybuf passed (as void pointer) 
to the kernel struct. Here we use strncpy since it allows to set a defined size(keylen received from user). Since the hash may not be null terminated,
this helps us prevent reading garbage values.

Afterwards, we move to the files. Since names can have many issues, like being too long etc, we use the getname() function to check for all these. This function is defined
in namei.c and needed to be exported manually. Once safe to use, we copy the file names to the kernel struct.  

Afterwards, we try to open the files using filp_open(). Error checks added help to manage all errros here. We open the input file in read only mode. For the output file,
we choose O_RDWR|O_CREAT. O_CREAT means that the file is created if it does not exist. We also make sure to copy the input file mode to the output at this point.

Next, we check the inode of the both the files to verify that they are not the same files. If yes, an encryption/decryption/copy makes no sense. So, the program exits with
a -EINVAL error.

Next, for encryption/decryption, we hash the password hash received from user space. This is called the preamble. During encryption, these 16 bytes are written at the start
of the file, followed by file contents. For Hashing, we make use of the MD5 algorithm libraries defined in the Linux crypto API. During decryption, we read the file header
(starting 16 bytes) and compare to the 16 bytes generated by hashing the keybuf to authenticate the user file access. Note that, access check is only for decryption.
 
Afterwards, for the enc/decr options, we define a fixed IV of size 16 bytes. We also initialze the cipher struct to have it ready for enc/decr in the next steps.
 
Next, we pass the file structs to copyData(), which does 3 things. Read from the input file, at 0 or after offset length(parameter passed). The data read (with vfs_read) is stored 
in a buffer of size PAGE_SIZE. 2) Transform the contents of he buffer. The transformation is either encrypt, decrypt or doNothing(copy). 3) Pass the buffer to file write, which uses vfs_write
to write the data from the same buffer. If both operations are successful, we the move the read and write offset forward. If either of the operation fails, the copydata is aborted.

Lastly, the program checks and frees all kernel memeory that may be defined. If output was file was created by program and the operation failed(partial/complete), this file is deleted.
